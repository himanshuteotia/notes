### ✅ Most Common Algorithm Patterns

1. **Sliding Window**
   Efficiently find subarrays or substrings by maintaining a window over the input (fixed or dynamic size).

2. **Two Pointers**
   Use two pointers (start and end) to scan or compare values—commonly used in sorted arrays or strings.

3. **Fast and Slow Pointers**
   Detect cycles or middle elements by moving two pointers at different speeds.

4. **Binary Search**
   Efficient search in sorted structures or in decision-based problems with monotonic properties.

5. **Backtracking**
   Try all possibilities recursively; undo choices when they lead to invalid states.

6. **Depth-First Search (DFS)**
   Explore as deep as possible before backtracking—used in trees, graphs, and puzzles.

7. **Breadth-First Search (BFS)**
   Explore neighbors level-by-level—great for shortest path or spreading problems.

8. **Greedy**
   Make the best local choice at each step, hoping for global optimum.

9. **Dynamic Programming (DP)**
   Break problems into overlapping subproblems and store solutions to avoid recomputation.

10. **Divide and Conquer**
    Divide the problem into subproblems, solve them recursively, and combine the results.

11. **Topological Sort**
    Used to order tasks (nodes) with dependencies in directed acyclic graphs (DAGs).

12. **Union-Find (Disjoint Set)**
    Track a set of connected components, often used in Kruskal’s MST or cycle detection.

13. **Bit Manipulation**
    Solve problems using bitwise operations, often used for sets, toggling, and masks.

14. **Prefix Sum / Difference Array**
    Pre-compute sums or frequencies to answer range queries efficiently.

15. **Heap / Priority Queue**
    Access the smallest or largest elements efficiently—used in Dijkstra, merging sorted lists, etc.
